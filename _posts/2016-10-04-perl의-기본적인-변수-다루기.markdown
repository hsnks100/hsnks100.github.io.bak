---
layout: post
title: "perl의 기본적인 변수 다루기"
author: 코딩도사(hsnks100@gmail.com)
date: 2016-10-04 00:00 +0900
tags: perl
comments: true
---
* table of contents
{:toc}


# perl 의 변수형

perl 은 기본적인 변수가 3가지 타입이 있다. $, %, @ 만 잘 쓰면 perl 에서 변수를 다루는데 무리가 없다. 

하지만 세상에 호락호락한 언어가 있는가. 어떻게 하든 복잡한 구조를 표현하는덴 복잡한 코드 구조가 필요하게 된다.

perl 에서도 마찬가지로 살짝은 언어의 side 문법을 알고 있어야 무리없이 코딩이 가능하다.

# 기본사용법
## $
보통의 언어에서 다루는 그냥 숫자나 문자열을 담는 타입이다. 스칼라(scalar) 연산이라고도 하는데, 스칼라는 어떤 방향성이 없는것을 뜻한다. 값 그 자체를 뽑을 때 쓰인다.

``` perl
$var = 1;
$var2 = "string";
$var3 = 333;

print "$var, $var2, $var3"; 

```
이런식으로 쓰면 된다. 가장 기초적인 변수고 쓰는데 큰 무리가 없다. 더 이상 설명할 것도 없다.


## @ array
@는 array 타입을 다루는 명령언데 @ => a => array 라고 연상하면 @ 를 헷갈리는 일은 없을 것이다. 

``` perl
my @arr = ("my", "name", "is", "ksoo"); 

print "$arr[0], $arr[1], $arr[2], $arr[3]\n"; 
```

초기화는 @ 를 이용해 배열 선언후 괄호 사이에 원하는 값을 넣는다. 값에 접근할 때는 $ 를 써야 하는데, 그 이유는 얻어지는 값이 배열이 아니고 값이기 때문이다.

배열의 길이를 구하려면 @arr 를 쓰면 된다.

``` perl
my $arrLength = @arr;
print $arrLength;
```

좀 더 명시적으로 표현하고 싶은 perl 프로그래머들은 my $arrLength = scalar @arr; 를 즐겨쓴다.  

## % hash
% 는 dictionary(hash) 타입을 나타내는데, 

``` perl
%name2email = (
  "ksoo" => "ksoo@gmail.com",
  "gsoo" => "gsoo@gmail.com"
  "young" => "young@gmail.com"
  );

print "$name2email{ksoo}\n";
print "$name2email{gsoo}\n";
```

이러한 구조로 쓰면 선언은 간단하다.
keys 함수로 key 만 뽑아낼 수도 있으며, 뽑아낸 키를 sort 로 정렬도 가능하다.  
다만 저장된 값을 얻어올 때는 $ 연산자로 구해야 한다. 이는 값 자체는 scalar 이기 때문이다.


# 기본을 넘어서
기본만 알고 모든것을 할 수 있다면 다행이겠지만, 기본을 넘어서야 하는 일도 생긴다. 

여기서는 조금 복잡한 자료구조를 perl 로 표현하는 방법을 살펴 본다.

array 와 hash 는 서로 변환이 가능하다. 앞서 보았던 코드를 보자.

``` perl
%name2email = (
  "ksoo" => "ksoo@gmail.com",
  "gsoo" => "gsoo@gmail.com"
  "young" => "young@gmail.com"
  );

@arr = %name2email; 

```

```
|| $VAR1 = [
||           'young',
||           'young@gmail.com',
||           'ksoo',
||           'ksoo@gmail.com',
||           'gsoo',
||           'gsoo@gmail.com'
||         ];
|| $VAR1 = {
||           'young' => 'young@gmail.com',
||           'ksoo' => 'ksoo@gmail.com',
||           'gsoo' => 'gsoo@gmail.com'
||         };
```

@arr 와 %name2email 을 출력해보면 위와 같이 나온다. 

더 진행하기에 앞서 배열의 index 접근은 [] 를 이용하고, 해시의 접근은 {} 로 한다는 사실을 기억하자.

# reference 와 복잡한 자료구조
이미 소개된 @, $, % 를 이용하여 모든 자료구조를 표현할 수 있을 것 같지만 한가지 빠진 조건이 있다. perl 은 배열이든 해시든 스칼라값만을 원소로 가진다.

예를 들면

``` perl
@arr = ("ksoo", "gsoo");
@values = (1, 2, 3, 4, 5);
@arr[1] = @values;

```

위 코드의 의도했던 바는 

```
|| $VAR1 = [
||           'ksoo',
||           [
||             1,
||             2,
||             3,
||             4,
||             5
||           ]
||         ];
```

이와 같을 것이다. 하지만 결과는 ['ksoo', 5] 라는 참혹한 결과를 가지게 된다. @values 라는 표현식은 scalar @values 라는 표현식의 줄임이고, scalar @values 는 @values 배열의 크기를 리턴한다.

우리가 원하는 동작을 하게 하려면 어떻게 해야하는가?

perl 에서는 reference (\) 라는게 있다. \ 뒤에 오는 표현식의 reference 를 반환한다.

``` perl 
$var1 = "test string";
$var2 = \$var1;

print "$var2\n";
print "${$var2}\n";
print "$$var2\n";

$$var2 = "hello reference";
print "-----------------\n";
print "$var1\n";
```

결과는 

``` 
|| SCALAR(0x1538050)
|| test string
|| test string
|| -----------------
|| hello reference 
```

$var2 를 출력하고자 했는데 이 값은 SCALAR 의 reference 라고 나온다. reference 의 값을 알기 위해서는 reference 종류에 대한 기호를 쓰고, {} 으로 감싼다.

표현이 명확할 때는 ${$var} 로 쓰지 않고 $$var 으로 써도 인식한다. 그리고 $$var2 를 고쳐본 결과 예상한 대로 원본 $var1 의 값이 바꼈음을 알 수 있다.


















